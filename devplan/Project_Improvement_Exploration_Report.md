# 🚀 프로젝트 개선 탐색 보고서

> 이 문서는 Vibe Coding Report VS Code 확장에서 자동으로 관리됩니다.  
> **적용된 개선 항목은 자동으로 필터링되어 미적용 항목만 표시됩니다.**
>
> 💡 **구체적인 구현 코드는 `Prompt.md` 파일을 참조하세요.**

---

## 📋 프로젝트 정보

| 항목 | 값 |
|------|-----|
| **프로젝트명** | I2g |
| **최초 분석일** | 2025-12-23 12:40 |

---

<!-- AUTO-ERROR-EXPLORATION-START -->
## 🔍 오류 및 리스크 탐색 절차

> 이 섹션은 개선 항목이 어떤 기준으로 도출되었는지를 설명합니다.

### 1. 데이터 수집
- 최근 빌드/테스트/런타임 로그 분석
- VS Code 문제 패널(Problems) 확인
- Git diff 및 커밋 메시지 검토
- TODO/FIXME 주석 스캔

### 2. 자동 분석
- 테스트 실패/스킵 케이스 분류
- 빌드 오류/경고 메시지 그룹화
- 빈번하게 수정되는 파일/모듈 탐지
- 정적 분석(lint, type-check) 결과 검토

### 3. 개선 후보 도출
- 동일 원인의 오류/경고를 하나의 "개선 항목 후보"로 묶기
- 영향도(테스트 실패, 빌드 실패, 성능 저하)에 따라 우선순위 부여
- 프로젝트 비전과의 일치 여부 검토

### 4. 최종 백로그 정제
- 복잡도/리스크 대비 효용 검토
- 완료 기준 명시
- 관련 평가 점수 카테고리 매핑
<!-- AUTO-ERROR-EXPLORATION-END -->

---

## 📌 사용 방법

1. 이 보고서의 개선 항목을 검토합니다
2. 적용하고 싶은 항목을 선택하여 `Prompt.md`를 생성합니다
3. AI 에이전트(Copilot Chat 등)에 붙여넣어 구현을 요청합니다
4. 다음 보고서 업데이트 시 적용된 항목은 자동으로 제외됩니다

---

<!-- AUTO-SUMMARY-START -->
## 📊 개선 현황 요약

- 본 보고서는 **미적용(대기)** 개선 항목만 포함합니다(완료 이력/세션 로그는 `Session_History.md`에서 관리).
- 현재 코드베이스는 `gui/`(GUI·CLI·코어) + `tests/` 중심의 소형 구조이며, **배포/운영 안전장치(CI) → 유지보수 표준화(패키지/아티팩트) → 성능·사용성 확장** 순으로 우선순위를 재정렬했습니다.

| 우선순위 | 대기 개수 |
|:---:|:---:|
| 🔴 P1 | 1 |
| 🟡 P2 | 3 |
| 🟢 P3 | 1 |
| 🚀 OPT | 1 |

| # | 항목명 | 우선순위 | 카테고리 |
|:---:|:---|:---:|:---|
| 1 | CI 파이프라인 구축(테스트/정적 체크) | P1 | 🧪 테스트 / 📦 배포 |
| 2 | 리포지토리 아티팩트/캐시 정책 및 릴리스 절차 정비 | P2 | 📦 배포 / 🧹 유지보수 |
| 3 | `gui` 패키지 구조 정비(Import/경로/테스트 로딩 개선) | P2 | 🧹 코드 품질 |
| 4 | CLI 재귀 처리 및 출력 구조 옵션 확장 | P2 | ⚙️ 자동화 |
| 5 | GUI 파라미터 프리셋/프로파일 기능 추가 | P3 | ✨ 기능 추가 |
| 6 | `cleanup_core` 메모리/성능 최적화(배열/프론티어 처리) | OPT | 🚀 성능 / 🧹 품질 |

- **P1:** 변경이 “머지/릴리스”로 이어지기 전에 자동으로 검증되도록 CI(테스트·정적 체크)를 최우선으로 구축
- **P2:** 협업/유지보수 비용을 낮추는 표준화(패키지 구조, 아티팩트/릴리스 정책) + 실제 작업 폴더 구조 대응(CLI 재귀) 강화
- **P3:** 사용자 편의 기능(프리셋/프로파일)로 반복 설정 비용을 줄여 성공률과 재현성을 높임
- **OPT:** 대형 이미지에서 체감 성능을 좌우하는 메모리/반복 연산을 줄이고, 성능 회귀를 측정 가능하게 만듦
<!-- AUTO-SUMMARY-END -->

---

<!-- AUTO-IMPROVEMENT-LIST-START -->
## 📝 개선 항목 목록

### 🔴 중요 (P1)

#### [P1-1] CI 파이프라인 구축(테스트/정적 체크)

| 항목 | 내용 |
|------|------|
| **ID** | `ci-pipeline-001` |
| **카테고리** | 📦 배포 / 🧪 테스트 |
| **복잡도** | Medium |
| **대상 파일** | `.github/workflows/ci.yml`(신규), `requirements-dev.txt`, `gui/requirements.txt`, `tests/` |
| **Origin** | static-analysis |
| **리스크 레벨** | high |
| **관련 평가 카테고리** | productionReadiness, testCoverage, codeQuality |

- **현재 상태:** 테스트는 존재하지만 로컬 실행에 의존하며, PR 단위 자동 검증(품질 게이트)이 없습니다.
- **문제점 (Problem):** 파이썬 버전/의존성/환경 차이로 인해 회귀가 “머지 이후”에 발견될 수 있습니다.
- **영향 (Impact):** 릴리스 안정성 저하, 회귀 유입 가능성 증가, 개선(OPT/기능) 작업의 변경 리스크 확대.
- **원인 (Cause):** 자동 실행 워크플로우와 표준 검증 커맨드가 정의되어 있지 않습니다.
- **개선 내용 (Proposed Solution):** GitHub Actions로 Python 3.10+에서 `pytest`/`compileall`을 실행하고, PR/푸시에 연동해 실패 시 병합을 차단합니다.
- **기대 효과:** 변경 안전성 확보 및 배포 신뢰도 향상(“항상 테스트가 도는” 개발 흐름 확립).

**완료 기준**
- [ ] CI 워크플로우가 PR/푸시에서 자동 실행
- [ ] `python -m pytest -q` 및 `python -m compileall -q gui` 통과
- [ ] 실패 시 병합 차단(필수 체크) 설정
- [ ] 실행 방법/요구 파이썬 버전 문서화(필요시)

### 🟡 중요 (P2)

#### [P2-1] 리포지토리 아티팩트/캐시 정책 및 릴리스 절차 정비

| 항목 | 내용 |
|------|------|
| **ID** | `release-artifact-001` |
| **카테고리** | 📦 배포 |
| **복잡도** | Low |
| **대상 파일** | `.gitignore`, `gui/dist/`, `.pytest_cache/`, `.vscode/`, `README.md` |
| **Origin** | static-analysis |
| **리스크 레벨** | medium |
| **관련 평가 카테고리** | productionReadiness, maintainability, documentation |

- **현재 상태:** 작업 트리에 빌드 산출물/캐시가 존재하며, “커밋/릴리스 대상”의 경계가 불명확합니다.
- **문제점 (Problem):** 버전 혼선(문서/EXE 불일치), 저장소 비대화, 빌드 재현성 저하로 이어질 수 있습니다.
- **영향 (Impact):** 사용자 신뢰 저하, 협업 비용 증가, 릴리스 품질 관리 난이도 상승.
- **원인 (Cause):** 아티팩트/캐시 보관 정책과 릴리스 절차(검증→산출→배포)가 문서/규칙으로 정의되어 있지 않습니다.
- **개선 내용 (Proposed Solution):** 산출물은 Releases로 분리하고, 캐시/바이너리는 git 추적에서 제외/정리하며, README에 릴리스 절차를 명문화합니다.
- **기대 효과:** 릴리스 재현성/추적 가능성 향상, 저장소 관리 비용 감소.

**완료 기준**
- [ ] 아티팩트/캐시 정리 및 추적 제외(정책 확정)
- [ ] 릴리스 절차(검증→빌드→배포) 문서화
- [ ] CI와 연동 가능한 검증 커맨드 명시
- [ ] 사용자 다운로드 경로/버전 표기 일관성 확보

#### [P2-2] `gui` 패키지 구조 정비(Import/경로/테스트 로딩 개선)

| 항목 | 내용 |
|------|------|
| **ID** | `pkg-layout-001` |
| **카테고리** | 🧹 코드 품질 |
| **복잡도** | Medium |
| **대상 파일** | `gui/__init__.py`(신규), `gui/main.py`, `gui/cleanup_cli.py`, `tests/`, `gui/BackgroundCleaner_v0.0.2.spec` |
| **Origin** | static-analysis |
| **리스크 레벨** | medium |
| **관련 평가 카테고리** | codeQuality, maintainability, productionReadiness |

- **현재 상태:** 실행 위치에 따라 import 경로가 달라질 수 있으며, 테스트는 `sys.path`를 직접 조작합니다.
- **문제점 (Problem):** 경로 의존성으로 인해 실행/테스트 재현성이 낮고, 구조 변경 시 영향 범위가 커집니다.
- **영향 (Impact):** 유지보수 난이도 상승, 신규 기여자 온보딩 지연, CI 도입 시 환경 이슈 가능성 증가.
- **원인 (Cause):** 패키지 엔트리포인트(`python -m ...`) 기준의 모듈 구조/상대 import 규칙이 정리되어 있지 않습니다.
- **개선 내용 (Proposed Solution):** `gui`를 패키지화하고 상대 import로 정리, 테스트는 `from gui...`로 로딩하도록 개선합니다.
- **기대 효과:** 실행/테스트 표준화로 유지보수성 향상 및 CI/배포 자동화의 기반 안정화.

**완료 기준**
- [ ] `python -m gui.main` 및 `python -m gui.cleanup_cli` 실행 가능
- [ ] 테스트에서 `sys.path` 조작 제거(표준 import로 전환)
- [ ] PyInstaller 스펙/실행 가이드 호환성 확인
- [ ] CI에서 동일 방식으로 재현 가능

#### [P2-3] CLI 재귀 처리 및 출력 구조 옵션 확장

| 항목 | 내용 |
|------|------|
| **ID** | `cli-recursive-001` |
| **카테고리** | 기타(⚙️ 자동화) |
| **복잡도** | Low |
| **대상 파일** | `gui/cleanup_cli.py`, `tests/test_cleanup_cli.py`, `README.md` |
| **Origin** | manual-idea |
| **리스크 레벨** | low |
| **관련 평가 카테고리** | usability, scalability, productionReadiness |

- **현재 상태:** 디렉터리 입력 시 1-depth 파일만 처리하며, 중첩 폴더는 사용자 수작업이 필요합니다.
- **문제점 (Problem):** 실제 작업 폴더(프로젝트 단위)에서 자동화 효율이 낮고 누락이 발생할 수 있습니다.
- **영향 (Impact):** 배치 처리 사용성이 낮아지고, 반복 작업 시간이 증가합니다.
- **원인 (Cause):** 입력 파일 탐색이 비재귀(`Path.iterdir`)로 구현되어 있습니다.
- **개선 내용 (Proposed Solution):** `--recursive` 옵션을 추가해 하위 폴더까지 순회하고, 필요 시 입력 폴더 구조를 출력에 보존합니다.
- **기대 효과:** 실제 폴더 구조에 대한 적합성이 높아져 CLI 활용도가 증가합니다.

**완료 기준**
- [ ] `--recursive` 동작 및 테스트 추가/통과
- [ ] 출력 경로 규칙 문서화(README)
- [ ] 오류 처리/종료 코드 일관성 유지
- [ ] 기본 동작(비재귀)은 기존과 호환
<!-- AUTO-IMPROVEMENT-LIST-END -->

---

<!-- AUTO-FEATURE-LIST-START -->
## ✨ 기능 추가 항목

> 새로운 사용자 가치(사용성/재현성)를 제공하는 P3 기능 백로그입니다.

### 🟢 개선 (P3)

#### [P3-1] GUI 파라미터 프리셋/프로파일 기능

| 항목 | 내용 |
|------|------|
| **ID** | `feat-gui-preset-001` |
| **카테고리** | ✨ 기능 추가 |
| **복잡도** | Medium |
| **대상 파일** | `gui/main.py`, `README.md`(선택) |
| **Origin** | manual-idea |
| **리스크 레벨** | low |
| **관련 평가 카테고리** | usability, documentation, productionReadiness |

- **현재 상태:** `Threshold`/`Dilation`을 이미지마다 수동으로 조정해야 하며, 성공 파라미터를 “저장/재사용”하기 어렵습니다.
- **기능 목적/가치:** (1) 반복 설정 비용 감소 (2) 결과 재현성 향상 (3) 초보 사용자 온보딩 가속(권장 프리셋 제공).
- **의존/연동:** `BackgroundCleanerApp`의 상태(`threshold_var`, `dilation_var`)를 저장/불러오며, 기존 처리 로직(`cleanup_background`)은 변경하지 않습니다.
- **구현 전략:** (1) 프리셋 드롭다운 + 저장/삭제 UI 추가 (2) 로컬 JSON(사용자 홈 또는 프로젝트 하위)로 프리셋 영속화 (3) “기본 프리셋(권장)” 몇 개를 내장하고 README에 사용 예시 추가(선택).
- **기대 효과:** 반복 작업의 속도와 일관성이 개선되고, 파라미터 튜닝에 대한 시행착오가 줄어듭니다.

**완료 기준**
- [ ] 주요 코드 리팩토링 및 구현 완료
- [ ] 관련 테스트 추가/수정 및 통과
- [ ] 빌드 및 린트 에러 없음
- [ ] 문서 또는 주석 보완 (필요시)
<!-- AUTO-FEATURE-LIST-END -->

---

<!-- AUTO-OPTIMIZATION-START -->
## 🚀 코드 품질 및 성능 최적화

> 기존 기능을 해치지 않으면서 코드 품질과 성능을 향상시킬 수 있는 개선점입니다.

### 1) 일반 분석(요약)
- **메모리 사용량:** `visited/removed/protected`가 “2차원 bool 리스트”로 유지되어 해상도 증가 시 파이썬 오브젝트 오버헤드가 큽니다.
- **후보 순회 오버헤드:** dilation은 프론티어 기반이지만 `set` + `sorted(frontier)`를 매 패스 수행해 후보가 큰 경우 비용이 커질 수 있습니다.
- **중복 판정:** 배경 유사도 판정(`is_similar`)이 후보 픽셀마다 반복 호출되어 코너 픽셀 비교가 누적 비용이 됩니다.
- **가독성/변경 안전성:** 핵심 알고리즘이 단일 함수에 길게 존재해 국소 수정 난이도가 높으며, 최적화 시 회귀 위험이 있습니다(테스트/CI와 함께 추진 권장).
- **측정/검증:** `processing_time_ms` 외에도 표준 라이브러리(`tracemalloc`)로 메모리 사용량 변화를 측정해 “성능/메모리”를 동시에 관리할 수 있습니다.

### 🚀 코드 최적화 (OPT-1)

| 항목 | 내용 |
|------|------|
| **ID** | `opt-cleanup-core-memory-001` |
| **카테고리** | 🚀 코드 최적화 / ⚙️ 성능 튜닝 |
| **영향 범위** | 성능 / 품질 |
| **대상 파일** | `gui/cleanup_core.py`, `tests/test_cleanup_core.py` |

- **현재 상태:** 대형 이미지에서 (1) 2차원 bool 리스트의 메모리 오버헤드 (2) dilation 프론티어 정렬/중복 판정 비용이 누적되어 처리 시간이 길어질 수 있습니다.
- **최적화 내용:**
  1. **비트맵/바이트 배열로 치환:** `visited/removed/protected`를 `bytearray` 등 “평탄화된 배열”로 전환해 메모리 사용량과 접근 오버헤드를 줄입니다.
  2. **프론티어 처리 최적화:** 정렬 의존을 줄이되(또는 최소화하되) 결과의 결정성/재현성을 유지하는 후보 처리 방식을 적용합니다.
  3. **중복 판정 축소:** 코너 비교/알파 조건 등 반복되는 판정을 로컬 변수화/단순 캐시로 최적화합니다(품질 유지 전제).
- **예상 효과:** 대형 이미지에서 메모리 사용량 감소, p50/p95 처리 시간 단축, 동일 품질 유지(윤곽선/내부 콘텐츠 보존).
- **측정 지표:** 동일 입력/파라미터에서 (1) `processing_time_ms` 전후 비교 (2) `tracemalloc` 기반 메모리 피크 비교 (3) 회귀 테스트(`tests/test_cleanup_core.py`) 통과.
<!-- AUTO-OPTIMIZATION-END -->
